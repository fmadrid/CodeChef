Please use this Google doc to code during your interview. To free your hands for coding, we recommend that you use a headset or a phone with speaker option.

Recent Paper: https://github.com/fmadrid/LBLR

A string in C language?

char* str;
str = {..., ‘\0’};

1: Implement a function to convert an integer to C style string.

int abs(const int& n) {
	if(n < 0) return n * -1;
	else return n;
}


char* toString(int num) {

	// Get the ‘length’ of the integer
	int temp = abs(num);
	int length = 1;
	
	// Consider the case 550
	do {
		length++;
		temp /= 10;
	}while(temp != 0);	2, 12, 3, 1, 4, 0
	%= -> return the result of temp % 10?
	length 4

	1 550
	2 55
	3 
	if(num < 0) length++;
	length 5

	// Default value is ‘\0’
	char* str = new char[length];

	if(num < 0) str[0] = ‘-’;
	str[length - 1] ‘\0’;

	// Append digits to str
	temp = abs(num); 123
	int pos = length - 2; pos = 3
	num = 55
	pos 2
	do {
		str[pos--] = temp % 10;	5 5
temp /= 10;
	}while(temp != 0 );	pos 2 temp 12 pos 1 temp 1
	pos = 1
temp = 5;


	return str;
	
}

-123	
0
123
Given some integer n, we want the STRING representation of n.
n is some integer between the range of INT_MIN and INT_MAX (-2.147 billion to 2.147 billion)

123456
Iterate through each digit using the modulus operator, and then convert the digit to a char and append to a character array

If n is negative we must allocate space to accomodate the -

Get the size of the integer (i.e. number of digits)
Check if negative (increase the size by 1)
If n == 0…



Thoughts on C
char* cstr;
int n = atoi(cstr);

signed int [-2^31 - 1, 2^31 - 1]


2: Determine whether a  word can be decomposed into other valid dictionary words by removing one letter at a time and get another valid word at each step until you have a one letter word left. 
bool CanDecompose(const string word)

Example:

BANK -> True 			MY -> False
BANK 				
BAN				
AN 
A

abcd -> anotherword. (Keep or remove a) (Keep or remove b), … (Keep or remove d)

bool initializeDecompose(const string word) {
	map<string, bool> results;
	return CanDecompose(word, results);

bool CanDecompose(const string word, map<string, bool>& results) {

if(word.empty()) {
	results.insert(make_pair(word, false));
return false;
}
	
	if(word.length() == 1 && myDictioanary.find(word) != myDictionary.end())
		return true;

	// Couldn’t Find it
	if(myDictionary.find(word) == myDictioanry.end()) {
		results.insert(make_pair(word, false));
return false;
}
	
	for(int i = 0; i < word.length(); i++) {

		// Not including character word[i]
		string newString = Prefix(i) + Suffix(i);

if(map.contains(newString) is false) continue;
if(CanDecompose(newString), results) return true;
	}

	results.insert(make_pair(word, false));
	return false;

}

ABBA
AB_A
A_BA
ABCDEFG

ABC
AB_
A__

A_C
A__

n! -> n! / n n! / (n-1)

Keep an external map to indicate successes or failures
map(“aba”) = false;
